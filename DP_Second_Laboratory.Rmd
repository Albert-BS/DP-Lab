---
title: "DP Second Laboratory"
author:
- Teresa Ricciardi
- Albert Bertran
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load, message=FALSE, warning=FALSE}
library(sdcMicro)
data("free1") # loads the dataset
```

```{r}
newdataset<-free1
```

```{r}
v <- table(newdataset[,"MARSTAT"])
v
```
```{r}
mdat <- matrix(c(0.5,0.4,0.1,0,
                 0.1,0.6,0.2,0.1,
                 0.1,0.3,0.6,0,
                 0,0.1,0.2,0.7), nrow = 4, byrow = TRUE, dimnames = list(c("single","married","divorced","widow"), c("single","married","divorced","widow")))
```

```{r}
crossprod(v, mdat)
```

```{r}
newdataset<-as.data.frame(newdataset)
```


```{r}
#sdcApp()
```

## 2.Microaggregation

### a) Compare the univariate, multivariate simple, and mdav microaggregation algorithms.

#### 1. Create an sdc object with the free1 dataset using REGION, SEX, AGE and MARSTAT as categorical variables and INCOME, ASSETS and DEBTS as numeric variables.

```{r}
dataset32<-free1

dataset32<-as.data.frame(dataset32)

sdc <- createSdcObj(
  dat = dataset32,
  keyVars = c("REGION","SEX","AGE","MARSTAT"),
  numVars = c("INCOME","ASSETS","DEBTS")
)
sdc <- varToFactor(sdc, "REGION")
sdc <- varToFactor(sdc, "SEX")
sdc <- varToFactor(sdc, "AGE")
sdc <- varToFactor(sdc, "MARSTAT")
```

#### 2. Execute the different microaggregation algorithms using 𝑘 = 4 and compute the execution time for each of them. (𝑘 is the minimum size of each group).

```{r}
# mdav, single, onedims
print("Mdav algorithm time:")
startMdav <- Sys.time()
mdavSdc <- microaggregation(obj = sdc, method = "mdav", aggr  = 4)
endMdav <- Sys.time()
mdav_time <- round(endMdav-startMdav,4)
mdav_time

print("Single algorithm time:")
startSingle <- Sys.time()
singleSdc <- microaggregation(obj = sdc, method = "single", aggr = 4)
endSingle <- Sys.time()
single_time <- round(endSingle-startSingle,4)
single_time

print("Onedims algorithm time:")
startOnedims <- Sys.time()
onedimsSdc <- microaggregation(obj = sdc, method = "onedims", aggr = 4)
endOnedims <- Sys.time()
onedims_time <- round(endOnedims-startOnedims,4)
onedims_time
```
#### 3. From the new_sdc object get the following risk and utility measurements.

```{r}
mdav_numeric <- mdavSdc@risk$numeric
single_numeric <- singleSdc@risk$numeric
onedims_numeric <- onedimsSdc@risk$numeric
```

```{r}
mdav_util <- mdavSdc@utility$il1
single_util <- singleSdc@utility$il1
onedim_util <- onedimsSdc@utility$il1
```

```{r}
mdavSdc@utility$eigen
singleSdc@utility$eigen
onedimsSdc@utility$eigen
```
Replicate the above with each algorithm.


```{r}
histogram = c()
```


```{r}
original <- sdc@origData[,sdc@numVars]
meanOrig <- c(mean(original[,1]), mean(original[,2]), mean(original[,3]))
sst <- sum((original - meanOrig)^2)
for (k in 2:100) {
  sdcMdavFor <- microaggregation(obj = sdc, method = "mdav", aggr = k)
  manip <- sdcMdavFor@manipNumVars
  sse <- sum((original - manip)^2)
  L <- sse / sst
  histogram[k] <- L
}
plot(histogram)

```



